{"pages":[{"title":"文件分类","text":"","link":"/categories/index.html"}],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server 这是简介这是简介这是简介这是简介这是简介这是简介这是简介这是简介这是简介这是简介 这里有更多内容更多内容更多内容更多内容更多内容更多内容更多内容更多内容更多内容更多内容更多内容更多内容更多内容更多内容更多内容更多内容更多内容 Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2017/05/26/hello-world/"},{"title":"设计模式之单例模式","text":"单例模式 定义 保证一个类仅有一个实例，并提供一个访问它的全局访问点。 适用场景 想确保任何情况下都只有一个实例。比如计数器、线程池、数据库连接池等等。 优点 在内存只有一个实例，减少内存开销。 可以避免对资源的多重占用。 设置全局访问点，严格控制访问。 重点 私有构造器：单例模式需要将构造函数私有化，防止外部创建实例。 线程安全：通过锁保证线程安全，通过Double-Check较少了不必要的锁开销 延迟加载(懒汉、饿汉)、 序列化和反序列化安全、 反射攻击 饿汉式 ​ 饿汉式单例模式就是在类初始化的时候完成实例的初始化，恶汉式的优点就是简单，同时也使用类的静态初始化保证了线程安全，缺点就是不能延迟加载(按需加载)，可能造成不必要的内存开销(没用到、实例很大)。 懒汉式 ​ 懒汉式和饿汉式的主要区别就是延迟加载，懒汉式在类初始化时只声明变量并没有完成初始化操作，只有当应用调用时才会完成变量的初始化操作。 多线程访问的问题 ​ 在多线程环境下，当多线程同时调用LazySingleton.getInstance()来获取实例时，可能造成创建多个实例。我们可以通过同步时锁getInstance2()来避免这样的问题。虽然getInstance2()解决了多线程访问的问题，但是每次调用getInstance2()都会创建锁，这就造成了不必要的锁开销。我们通过双重锁定策略或静态初始化来解决这个问题。 双重锁定 ​ 双重锁定只有当实例未创建时才会加锁处理。 静态初始化 ​ 基于类初始化的延迟加载解决方案， 12345678910111213141516/** * @Author: toobug * @Description 基于类初始化的延迟加载解决方案 */public class StaticInnerClassSingleton { // 定义内部类 private static class InnerClass { private static StaticInnerClassSingleton singleton = new StaticInnerClassSingleton(); } private StaticInnerClassSingleton() { } public StaticInnerClassSingleton getInstance() { return InnerClass.singleton; }} 序列化/反序列破坏单例 ​ 如果单例类实现了序列化接口Serializable，我们可以通过反序列化ObjectInputStream.getObject()创建新的Singleton实例，这显然不符合单例模式的定义，我们可以再Singleton类定义readResolve()返回单例实例来避免，反序列化通过反射重新创建实例。 反射攻击 如何进行反射防御呢 123456private HungrySingleton() { // 对于类初始化时创建的实例,我们修改构造函数防止反射攻击 if (hungrySingleton != null) { throw new RuntimeException(\"单例构造禁止通过反射调用\"); }} 单例-枚举类 单例模式的最佳实践，可以保证线程安全和防止反射攻击。 Enum只有一个有参构造器，而且反射代码中规定不能实例化枚举类型 可能看另一边博客 [单例模式]: 容器单例 举例spring","link":"/2017/05/26/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"title":"设计模式的六大原则","text":"设计模式的六大原则1、开闭原则（Open Close Principle） ​ 开闭原则表示软件实体 (类、模块、函数等等)对扩展开放，对修改关闭。通俗来讲就是开发软件时，应考虑其后续的功能扩展，在进行这些扩展时，不需要对原来的程序进行修改。这样做的目的是保证程序的扩展性好，易于维护和升级。 ​ 在简单工厂模式中，如果工厂类使用逻辑判断来创建不同的产品，当需要新加产品时需要修改工厂类的创建逻辑，这就违背了开闭原则。开闭原则是面向对象的基石，实际上其他原则可以看作是实现开闭原则的工具和手段。 2、里氏代换原则（Liskov Substitution Principle） ​ 里氏代换原则中说任何基类可以出现的地方，子类一定可以出现，反之则不行。 ​ 里氏代换原则是继承复用的基石，子类可以扩展父类的功能，但是不能改变父类原有的功能。通俗讲，只有当子类可以替换掉父类，且软件功能不受到影响时，父类才能真正被复用，而子类也能够在父类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而父类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。 ​ 里氏替换原则有4层含义 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。 子类中可以增加自己特有的方法。 当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。 当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。 3、依赖倒转原则（Dependence Inversion Principle） ​ 依赖倒置原则简单讲就是针对接口编程，依赖于抽象而不依赖于具体。 ​ 高层模块不应该依赖底层模块，二者都应该依赖其抽象了； ​ 抽象不依赖细节； ​ 细节应该依赖抽象。 ​ 这个原则是开闭原则的基础，具体内容 4、接口隔离原则（Interface Segregation Principle） ​ 接口隔离原则强调：客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上 ​ 具有两种含义：1、用户不应该依赖它不需要的借口；2、类间的依赖关系应该建立在最小的的接口上。通俗来说就是：接口尽量细化，同时保证接口中的方法尽量的少。一个接口中包含太多的行为时，会导致它们与客户端的不正常依赖关系，要做的就是分离接口，从而实现解耦。 ​ 5、迪米特法则，又称最少知道原则（Demeter Principle） ​ 最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。 ​ 举例来说：你需要买房子了，现在存在三座合适的楼盘A，B，C，但是你不必直接去楼盘买楼，而是在售楼处去了解情况。这样就减少了你（购房者）与楼盘两个类之间耦合。 6、合成复用原则（Composite Reuse Principle） ​ 合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。 7、单一职责原则 ​ 单一职责原则是类的职责划分应该尽量简单。通俗的说，即一个类只负责一项职责 ​ 怎么理解呢，假设我们定义一个车Car的抽象类，它有启动、停止、行驶三个方法，公交车Bus通过继承拥有了这三种功能，但是公交车还要有刷卡功能啊，在Car类定义收费功能显然就不符合单一职责原则，通常抽象化刷卡收费功能完成bus的功能扩张。 总结 单一职责原则告诉我们实现类要职责单一 里氏替换原则告诉我们不要破坏继承体系 依赖倒置原则告诉我们要面向接口编程 接口隔离原则告诉我们在设计接口的时候要精简单一 迪米特原则告诉我们要降低耦合 开闭原则是总纲，告诉我们要对扩展开放，对修改关闭","link":"/2019/05/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8E%9F%E5%88%99/"}],"tags":[],"categories":[{"name":"随笔","slug":"随笔","link":"/categories/%E9%9A%8F%E7%AC%94/"},{"name":"设计模式","slug":"设计模式","link":"/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]}