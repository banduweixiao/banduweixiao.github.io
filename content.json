{"pages":[{"title":"文件分类","text":"","link":"/categories/index.html"}],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server 这是简介这是简介这是简介这是简介这是简介这是简介这是简介这是简介这是简介这是简介 这里有更多内容更多内容更多内容更多内容更多内容更多内容更多内容更多内容更多内容更多内容更多内容更多内容更多内容更多内容更多内容更多内容更多内容 Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2017/05/26/hello-world/"},{"title":"page","text":"","link":"/2019/12/13/about/me/"},{"title":"04科普5G","text":"有线？无线？ 通信技术，无论什么黑科技白科技，归根到底，就分为两种——有线通信和无线通信。 基本上就是用的铜线、光纤这些线缆，统称为有线介质。 ​ 在实验室中，单条光纤最大速度已达到了26Tbps 大家都知道，无线通信就是利用电磁波进行通信。电波和光波，都属于电磁波。电磁波的功能特性，是由它的频率决定的。不同频率的电磁波，有不同的属性特点，从而有不同的用途。例如，高频的γ射线，具有很大的杀伤力，可以用来治疗肿瘤。 电磁波的显著特点：频率越高，波长越短，越趋近于直线传播（绕射能力越差）。频率越高，在传播介质中的衰减也越大。 移动通信如果用了高频段，那么它最大的问题，就是传输距离大幅缩短，覆盖能力大幅减弱。覆盖同一个区域，需要的5G基站数量，将大大超过4G。基站数量的增加意味着成本的增加。 所以，基于以上原因，在高频率的前提下，为了减轻网络建设方面的成本压力，5G必须寻找新的出路。就是微基站。 手机的通信频率越来越高，波长越来越短，天线也就跟着变短啦！ 毫米波通信，天线也变成毫米级。。。 5G的第三大杀手锏Ｍassive MIMO（多天线技术） 5G的第五大特点——D2D，也就是Device to Device（设备到设备） 5G产业报告预测：到2035年，5G将在全球创造12.3万亿美元经济价值，全球5G价值链将创造3.5万亿美元产值，同时创造2200万个工作岗位。","link":"/2019/12/13/04%E7%A7%91%E6%99%AE5G/"},{"title":"01SpringBoot参数传递的正确姿势","text":"[TOC] 后端想接收数组、集合 - Integer[] ids、List&lt;-Integer&gt; ids后台代码 12345678910111213141516171819/** * 一、后台接收数组 */@PostMapping(\"/sys/array\")public Result array(@RequestParam(value = \"ids[]\") Integer[] ids) { logger.info(\"数据{}\", Arrays.asList(ids)); //业务逻辑 return Result.ok();}/** * 二、后台接收集合 */@PostMapping(\"/sys/array\")public Result array(@RequestParam(value = \"ids[]\") List&lt;Integer&gt; ids) { logger.info(\"数据{}\", ids.toString()); //业务逻辑 return Result.ok();} 前端调用 123456789101112var param = { \"ids\": [1, 2, 3]}$.ajax({ url: \"/sys/array\", data: param, type: \"post\", dataType: \"json\", success: function(data) { }}); 后台想接收集合实体对象 - (@RequestBody List&lt;-SysUser&gt; list)后台代码 12345678910111213/** * 后端想接收一个实体对象集合 List&lt;SysUser&gt; */@PostMapping(\"/sys/listUser\")public Result listUser(@RequestBody List&lt;SysUser&gt; list) { logger.info(\"数据{}\", list.size()); list.forEach(user-&gt;{ //输出实体对象 System.out.println(user.getUsername()); }); //业务逻辑 return Result.ok();} 前端调用 12345678910111213141516171819var list = [];list.push({ \"username\": \"小柒2012\", \"mobile\": \"17762288888\"});list.push({ \"username\": \"小柒2013\", \"mobile\": \"17762289999\"});$.ajax({ url: \"/sys/listUser\", data: JSON.stringify(list), type: \"post\", contentType: \"application/json\", dataType: \"json\", success: function(data) { }}); 工作中遇到的传参问题123456@PostMapping(\"/token\")public String testToken(@RequestBody(required = false) Dog dog,@RequestParam String id, HttpServletRequest request) { String token = request.getParameter(\"token\"); // 业务代码 return \"success\";} HttpServletRequest传参是在地址栏拼接的，因为有@RequestBody,前端依然需要设置contentType为application/json 总结@RequestBody注解，必须与 contentType 类型application/json配合使用。前端使用JSON.stringify() 把对象类型转换为字符串类型","link":"/2019/12/13/01SpringBoot%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF/"},{"title":"03Linux","text":"[TOC] 文件操作mkdir mkdir directoryName; //在当前目录下创建目录 mkdir one/two/three; //-p或–parents,递归创建目录,上层目录没有则一并创建 mkdir one two three; //多个目录的创建,目录之间用空格隔开 -Z 设置安全上下文 -m 目录权限设置 rmdir用法：rmdir [选项]… 目录…删除指定的空目录,若目录非空无法删除 -p –parents 递归删除,若父目录为空则一并删除 eg. rmdir -p a/b/c 等价于 rmdir a/b/c a/b a -v, –verbose 显示命令删除的详细执行过程 ​ –ignore-fail-on-non-empty 忽略仅由目录非空产生的所有错误 &gt; rmdir: 删除目录 “b” 失败: 目录非空","link":"/2019/12/13/03Linux/"},{"title":"02Oracle数据导出","text":"记录数据导出导出操作 备份文件导出目录:D:\\app\\gwDump(143) 1、通过操作系统认证的方式登录超级管理员用户sysdbasqlplus /nologconnect /as sysdba2、创建【逻辑目录】(该命令不会在操作系统创建真正的目录,手动建好)create directory gwdir as ‘D:\\app\\gwDump’;3、确认【逻辑目录】创建成功select * from dba_directories;4、给scott用户赋予在指定目录的操作权限grant read,write on directory gwdir to hytis; – 水雨情库grant read,write on directory gwdir to WATFN; – QUERY=&quot;WHERE STCD IN (SELECT STCD FROM ST_STBPRP_B WHERE ADDVCD = ‘361130’)&quot;","link":"/2019/12/13/02Oracle%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%87%BA/"},{"title":"05Redis命令","text":"[TOC] 字符串SET1SET key value [EX seconds][PX milliseconds] [NX|XX] 功能描述 ​ 将字符串value关联到key，时间复杂度为O(1)，如果key已经持有其他值，SET会覆写旧值。 可选参数 EX seconds: 将键的过期时间设置为seconds秒。执行SET key value EX seconds等同于SETEX key seconds value PX milliseconds: 将键的过期时间设置毫秒。SET key value PX milliseconds 等同于 PSETEX key millseconds value. NX: 只有键不存在时才进行设置操作，执行SET key value NX等同于SETNX key value XX: 只有键存在时才能进行设置操作 GET1GET key 功能描述 ​ 返回与key相关联的字符串值。如果key不存在返回特殊值nil，GET命令只能获取字符串的值，如果获取的key不是字符串类型，则返回一个错误(error) ERR Operation against a key holding the wrong kind of value APPEND key value1APPEND key value 功能描述 ​ 在键为key的字符串尾部追加新value，如果key不存在创建键为key值为value的字符串，返回追加后字符串的长度。 SETRANGE key offset value功能描述 ​ 从偏移量 offset 开始， 用 value 参数覆写(overwrite)键 key 储存的字符串值。不存在的键 key 当作空白字符串处理。如果偏移量超过原字符串长度，那么原字符和偏移量之间的空白将用零字节(zerobytes, &quot;\\x00&quot; )进行填充。 GETRANGE key start end功能描述 ​ 返回key存储的部分字符，字符串的截取范围由start和end两个偏移量决定(包含start、end)，负数偏移量表示从字符串尾部开始计数，-1表示最后一个字符，-2表示倒数第二个字符，以此类推。 INCR/DECR功能描述 为key存储的数字值加1。 如果key不存在，则将其初始化为0后在执行INCR命令。如果key存储的不是数字则报错。INCR返回的是key执行加1之后的值。 INCRBY/DECR key increment功能描述 为key存储的数字加上增量 INCRBYFLOAT key increment功能描述 为key上存储的值加上浮点数增量increment MSET key value [key value]功能描述 同时为多个键设置值。如果给定的key已经存在，那么MSET将使用新值取覆盖旧值。 MSET 是一个原子性(atomic)操作，所有给定键都会在同一时间内被设置，不会出现某些键被设置了但是另一些键没有被设置的情况。 OtherSETNX key value：SETNX是『SET if Not eXists』(如果不存在，则 SET)的简写 SETEX key seconds value PSETEX key milliseconds value GETSET key value：获取key的旧值，并将key设置为新value，如果没有旧值则返回nil STRLEN: 返回字符串的长度，如果key不存在返回0，key不是字符串则报错 MSETNX：当且仅当所有给定键都不存在时，为所有给定键设置值。如果有存在的key，那么MSETNX会拒绝所有key的设置操作 MEGET key [key ...]: 同时获取多个key 总结Redis字符串操作有如下几种分类 设置值/取值 设置过期时间/获取过期时间 同时设置值/取值 多数字的增加/减少 获取字符串长度 字符串截取/追加 哈希表HSET hash field value功能描述 将哈希表hash中域field的值设置为value。 如果哈希表不存在那么会新建哈希表并执行HSET操作。 如果域field已经存在，那么它的旧值新值替换。 当 HSET 命令在哈希表中新创建 field 域并成功为它设置值时， 命令返回 1 ； 如果域 field 已经存在于哈希表， 并且 HSET 命令成功使用新值覆盖了它的旧值， 那么命令返回 0 。 HSETNX hash field value功能描述 当哈希表hash中域field不存在时设置值为value. HDEL key field [field …]功能描述 删除哈希表key中 指定的域，不存在的域会被忽略。返回的是成功移除的域的数量，不包含被忽略的域。 Redis2.4以下HDEL只能删除单个，如果需要原子时间内删除多个域，请将命令包含在MULTI / EXEC HKEYS key功能描述 返回哈希表key中所有的域 HVALS key功能描述 返回哈希表key中所有域的值 HGETALL key功能描述 返回哈希表key中所有的域和值。 OtherHGET hash field ：获取hash表中的值，如果没有返回nil HEXISTS hash field：检查哈希表hash中是够存在域field，存在返回1，不存在返回0 HLEN key ： 返回哈希表key中域的数量，如果key不存在则返回0 HSTRLEN key field ： 返回字符串长度(哈希表key存储在域field的字符串长度)，3.2 版本以上可用 HINCRBY key field increment: 可以使用负数实现减操作 HINCRBYFLOAT key field increment ：加上浮点数增量increment HMSET key field value [field value …] HMGET key field [field ...] 列表","link":"/2019/12/13/05Redis%E5%91%BD%E4%BB%A4/"},{"title":"06Redis使用遇到的问题","text":"E:\\Study\\redis&gt;redis-server.exe redis.windows.conf[10860] 04 Dec 14:23:48.847 #The Windows version of Redis allocates a large memory mapped file for sharingthe heap with the forked process used in persistence operations. This filewill be created in the current working directory or the directory specified bythe ‘heapdir’ directive in the .conf file. Windows is reporting that there isinsufficient disk space available for this file (Windows error 0x70).You may fix this problem by either reducing the size of the Redis heap withthe –maxheap flag, or by moving the heap file to a local drive with sufficientspace.Please see the documentation included with the binary distributions for moredetails on the –maxheap and –heapdir flags.Redis can not continue. Exiting.","link":"/2019/12/13/06Redis%E4%BD%BF%E7%94%A8%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"},{"title":"07","text":"Graal 编译器是 Java 10 正式引入的实验性即时编译器，在国内同行口中被戏称为“甲骨文黑科技”。 1、需求2、设计表、设计接口文档3、原形4、项目搭建5、模块化开发 用户 登录、 注册、 个人信息查看、 密码修改(邮箱、手机号、第三方账户) 权限(普通用户发布图书、管理员可以审核、超级管理员所有功能) 图书 个人书架 图书发布(添加) -&gt; 管理员审核、 系统书城、 书籍分类、 查看图书(图书详情、电子书的下载、在线预览)、 评分评论 博客(富文本)、 收藏书评、 发布书评、交流 用户对用户 讨论组","link":"/2019/12/13/07/"},{"title":"09.跨域请求","text":"Geoserver服务跨域设置 https://www.cnblogs.com/ytwy/p/6823955.html","link":"/2019/12/13/09.%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82/"},{"title":"08Git","text":"很多人都知道，Linus在1991年创建了开源的Linux，从此，Linux系统不断发展，已经成为最大的服务器系统软件了。Linus虽然创建了Linux，但Linux的壮大是靠全世界热心的志愿者参与的，这么多人在世界各地为Linux编写代码，那Linux的代码是如何管理的呢？事实是，在2002年以前，世界各地的志愿者把源代码文件通过diff的方式发给Linus，然后由Linus本人通过手工方式合并代码！你也许会想，为什么Linus不把Linux代码放到版本控制系统里呢？不是有CVS、SVN这些免费的版本控制系统吗？因为Linus坚定地反对CVS和SVN，这些集中式的版本控制系统不但速度慢，而且必须联网才能使用。有一些商用的版本控制系统，虽然比CVS、SVN好用，但那是付费的，和Linux的开源精神不符。不过，到了2002年，Linux系统已经发展了十年了，代码库之大让Linus很难继续通过手工方式管理了，社区的弟兄们也对这种方式表达了强烈不满，于是Linus选择了一个商业的版本控制系统BitKeeper，BitKeeper的东家BitMover公司出于人道主义精神，授权Linux社区免费使用这个版本控制系统。安定团结的大好局面在2005年就被打破了，原因是Linux社区牛人聚集，不免沾染了一些梁山好汉的江湖习气。开发Samba的Andrew试图破解BitKeeper的协议（这么干的其实也不只他一个），被BitMover公司发现了（监控工作做得不错！），于是BitMover公司怒了，要收回Linux社区的免费使用权。Linus可以向BitMover公司道个歉，保证以后严格管教弟兄们，嗯，这是不可能的。实际情况是这样的：Linus花了两周时间自己用C写了一个分布式版本控制系统，这就是Git！一个月之内，Linux系统的源码已经由Git管理了！牛是怎么定义的呢？大家可以体会一下。Git迅速成为最流行的分布式版本控制系统，尤其是2008年，GitHub网站上线了，它为开源项目免费提供Git存储，无数开源项目开始迁移至GitHub，包括jQuery，PHP，Ruby等等。历史就是这么偶然，如果不是当年BitMover公司威胁Linux社区，可能现在我们就没有免费而超级好用的Git了。 创建版本库 git init命令把指定的目录变成Git可以管理的仓库， 添加文件到版本库 用命令git add告诉Git，把文件添加到仓库 用命令git commit告诉Git，把文件提交到仓库 其他命令 git status命令可以让我们时刻掌握仓库当前的状态 git diff顾名思义就是查看difference git diff &lt;file name&gt; git log --pretty=oneline 初始化一个Git仓库，使用git init命令。 添加文件到Git仓库，分两步： 使用命令git add &lt;file&gt;，注意，可反复多次使用，添加多个文件； 使用命令git commit -m &lt;message&gt;，完成。","link":"/2019/12/13/08Git/"},{"title":"10Linux","text":"Tempwget [download_url]: 下载资源 ssh root@47.94.218.93","link":"/2019/12/13/10Linux/"}],"tags":[{"name":"66","slug":"66","link":"/tags/66/"}],"categories":[{"name":"随笔","slug":"随笔","link":"/categories/%E9%9A%8F%E7%AC%94/"}]}